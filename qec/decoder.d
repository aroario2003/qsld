module qec.decoder;

import std.stdio;

import quantum.pure_state.qc;
import quantum.pure_state.gate_noise;

import linalg.vector;

import qec.stabilizer;

struct Decoder {
    QuantumCircuit* qc;

    this(QuantumCircuit* qc) {
        this.qc = qc;
    }

    // Maps every possible error that could have occured on N qubits
    // to its corresponding binary error vector and then computes the
    // syndrome which would result from that error vector and maps the
    // syndrome to the error vector.
    private Vector!int[Vector!int] map_syndrome_to_error_vector() {
        // This isn't ideal but it is what it is for now
        GateNoise noise = GateNoise(this.qc);
        string[] pauli_strings = noise.generate_pauli_combos(this.qc.num_qubits);

        Vector!int[Vector!int] syndrome_to_error_map;

        foreach (ps; pauli_strings) {
            Vector!int err_vec = Vector!int(2 * this.qc.num_qubits, new int[2 * this.qc.num_qubits]);
            err_vec.elems[] = 0;

            char[] pauli_ops = ps[].dup;

            for (int i = 0; i < pauli_ops.length; i++) {
                int qubit_idx = this.qc.num_qubits - 1 - i;
                switch (pauli_ops[i]) {
                case 'I':
                    break;
                case 'X':
                    err_vec[qubit_idx] = 1;
                    break;
                case 'Y':
                    err_vec[qubit_idx] = 1;
                    err_vec[this.qc.num_qubits + qubit_idx] = 1;
                    break;
                case 'Z':
                    err_vec[this.qc.num_qubits + qubit_idx] = 1;
                    break;
                default:
                    assert(false, "An invalid gate was provided to the syndrome mapping function");
                    break;
                }
            }

            Vector!int syndrome = this.qc.tableau.measure(err_vec);
            syndrome_to_error_map[syndrome] = err_vec;
        }

        return syndrome_to_error_map;
    }

    // Compare the original syndrome from the simulator to the generated syndrome from the error vector
    // generated by the pauli string. 
    private bool compare_syndrome(Vector!int original_syndrome, Vector!int generated_syndrome) {
        for (int i = 0; i < generated_syndrome.length; i++) {
            if (original_syndrome.elems[i] != generated_syndrome.elems[i]) {
                return false;
            }
        }
        return true;
    }

    // Convert the given generated error vector back into its pauli string form
    // to be able to apply it to the quantum state again, to reverse previous erroneous 
    // operations.
    private string convert_error_vector_to_pauli_string(Vector!int err_vec) {
        char[] pauli_string = new char[this.qc.num_qubits];
        int pauli_index = this.qc.num_qubits - 1;

        for (int i = 0; i < this.qc.num_qubits; i++) {
            if (err_vec[i] == 0 && err_vec[this.qc.num_qubits + i] == 0) {
                pauli_string[pauli_index] = 'I';
            } else if (err_vec[i] == 0 && err_vec[this.qc.num_qubits + i] == 1) {
                pauli_string[pauli_index] = 'Z';
            } else if (err_vec[i] == 1 && err_vec[this.qc.num_qubits + i] == 0) {
                pauli_string[pauli_index] = 'X';
            } else if (err_vec[i] == 1 && err_vec[this.qc.num_qubits + i] == 1) {
                pauli_string[pauli_index] = 'Y';
            }
            pauli_index--;
        }

        return pauli_string.idup;
    }

    /**
     * Decodes the original syndrome into an error which can then be re-applied
     * to the quantum state in order to reverse the operation. This is only possible 
     * because quantum gates are reversible
     *
     * params:
     * original_syndrome = The original syndrome bits measured from the original
     *                      error vector and tableau
     *
     * returns: The pauli string representing the error which ocurred on the quantum state
     */
    string decode(Vector!int original_syndrome) {
        Vector!int[Vector!int] syndrome_to_error_map = map_syndrome_to_error_vector();
        Vector!int err_vec;
        string error_pauli_string;

        foreach (generated_syndrome, error; syndrome_to_error_map) {
            if (compare_syndrome(original_syndrome, generated_syndrome)) {
                err_vec = syndrome_to_error_map[generated_syndrome];
                error_pauli_string = convert_error_vector_to_pauli_string(err_vec);
                break;
            }
        }

        return error_pauli_string;
    }

    /**
     * Corrects the quantum state based on the error pauli string
     * generated by the decode function
     *
     * params:
     * error_pauli_string = The string of pauli operators which represent the 
     *                      error which ocurred on the quantum state
     */
    void correct_state(string error_pauli_string) {
        int qubit_idx = 0;
        char[] pauli_array = error_pauli_string[].dup;

        for (int i = this.qc.num_qubits - 1; i >= 0; i--) {
            if (pauli_array[i] == 'I') {
                continue;
            } else if (pauli_array[i] == 'X') {
                this.qc.pauli_x(qubit_idx);
            } else if (pauli_array[i] == 'Y') {
                this.qc.pauli_y(qubit_idx);
            } else if (pauli_array[i] == 'Z') {
                this.qc.pauli_z(qubit_idx);
            }

            qubit_idx++;
        }
    }
}
